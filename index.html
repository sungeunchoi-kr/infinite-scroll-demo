<!DOCTYPE html>
<html lang="en" class="no-js">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Infinite Scroll Demo</title>

    <script type="module">
        document.documentElement.classList.remove('no-js');
        document.documentElement.classList.add('js');
    </script>

    <script src="https://unpkg.com/konva@^2/konva.min.js"></script>
</head>
<body style="margin: 0;">
    <div id="container">

    </div>

    <script>
        // Deterministic random
        function mulberry32(a) {
            let t = a += 0x6D2B79F5;
            t = Math.imul(t ^ t >>> 15, t | 1);
            t ^= t + Math.imul(t ^ t >>> 7, t | 61);
            return ((t ^ t >>> 14) >>> 0) / 4294967296;
        }

        // Image resource loader.
        function loadImagesFromURLs(imageSources) {
            return new Promise((resolve, reject) => {
                let enabled = true

                const doneflags = []
                const items = imageSources.map(src => {
                    const img = new Image()

                    // NOTE: gets called when the image is ready to be used.
                    img.onload = () => {
                        doneflags.push(src)
                    }

                    img.src = src
                    return img
                })

                const masterTimeout = setTimeout(() => {
                    enabled = false
                    reject(new Error('Image load timed out.'))
                }, 5 * 1000)

                let timer = null
                const checkIsDone = () => {
                    console.log(`loadImagesFromURLs: ${doneflags.length} / ${imageSources.length} loaded.`)
                    if (doneflags.length === imageSources.length) {
                        clearTimeout(timer)
                        clearTimeout(masterTimeout)

                        console.log(`loadImagesFromURLs: Finished loading ${doneflags.length} images.`)
                        return resolve(items)
                    }                    

                    if (enabled) {
                        timer = setTimeout(() => checkIsDone(), 50)
                    }
                }

                checkIsDone()
            })
        }
    </script>

    <script>
        const main = async () => {
            // Starting position of the canvas. We set it to some far away place from <0, 0> b/c
            // there's symmetry with the randomness at around the origin point.
            const startingPosition = {
                x: Math.floor( Math.random() * 10000),
                y: Math.floor( Math.random() * 10000),
            }

            // Setup Konva.
            const stage = new Konva.Stage({
                container: 'container',
                width: document.documentElement.clientWidth, //window.innerWidth,
                height: document.documentElement.clientHeight, //window.innerHeight,
                draggable: true
            })
            const layer = new Konva.Layer();
            stage.add(layer);

            //// Define cell width and height.
            const WIDTH = 200;
            const HEIGHT = 200;

            //// Define available color for each cell.
            // const items = [
            //     'red', 'yellow', 'green', 'blue', 'orange', 'gray',
            // ]

            // Define and load images
            const items = await loadImagesFromURLs([
                'https://www.musesessions.co/images/andreas-forsberg-rMdOHpO3h5E-unsplash-p-800.jpeg',
                'https://uploads-ssl.webflow.com/60011ca445a22c190aede614/60eb808d8c8efb04c77a68ea_file%20sharing-poster-00001.jpg',
                'https://www.musesessions.co/images/pelayo-arbues--elZhv-JysI-unsplash-p-500.jpeg',
                'https://www.musesessions.co/images/soundtrap-uCNrr-3i2oI-unsplash.jpg',
                'https://www.musesessions.co/images/omid-armin-0cbLoqUyz28-unsplash-p-500.jpeg',
            ])

            function _fillLayer() {
                //console.log(`pos=<${stage.x()}, ${stage.y()}>`)

                const startX = Math.floor((-stage.x() - stage.width()) / WIDTH) * WIDTH;
                const endX = Math.floor((-stage.x() + stage.width() * 2) / WIDTH) * WIDTH;
            
                const startY = Math.floor((-stage.y() - stage.height()) / HEIGHT) * HEIGHT;
                const endY = Math.floor((-stage.y() + stage.height() * 2) / HEIGHT) * HEIGHT;
            
                for (var x = startX; x < endX; x += WIDTH) {
                    for (var y = startY; y < endY; y += HEIGHT) {
                        let indexX = Math.abs((x + startingPosition.x) / WIDTH);
                        let indexY = Math.abs((y + startingPosition.y) / HEIGHT);

                        // map index |--> element in item, pseudo-random deterministically.
                        let randv = Math.floor( mulberry32(indexX * indexY) * 12345);
                        let item = items[ randv % items.length ];

                        //layer.add(new Konva.Rect({
                        //    x,
                        //    y,
                        //    width: WIDTH,
                        //    height: HEIGHT,
                        //    fill: item,
                        //}))
                        layer.add(new Konva.Image({
                            x, y,
                            width: WIDTH, height: HEIGHT,
                            image: item,
                        }))
                    }
                }
            }
            // Generates random cells on the canvas and draws the canvas.
            const generate = () => {
                console.log(new Date().toISOString() + ' generate()')
                layer.destroyChildren();
                _fillLayer();
                layer.draw();
            }

            // Drag end event listener.
            stage.on('dragend', () => {
                generate()
            })

            // Wheel event listener.
            let __wheelDebounceTimer = null
            stage.on('wheel', ev => {
                const {
                    deltaX,
                    deltaY,
                    wheelDeltaX,
                    wheelDeltaY,
                    which,
                    x, y
                } = ev.evt || {}

                stage.setX(stage.x() - deltaX)
                stage.setY(stage.y() - deltaY)

                clearTimeout(__wheelDebounceTimer)
                __wheelDebounceTimer = setTimeout(() => {
                    generate()
                }, 100)

                layer.draw();
            });

            generate();
        }

        main()
    </script>
</body>
</html>