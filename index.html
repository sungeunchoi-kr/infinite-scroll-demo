<!DOCTYPE html>
<html lang="en" class="no-js">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Infinite Scroll Demo</title>

    <script type="module">
        document.documentElement.classList.remove('no-js');
        document.documentElement.classList.add('js');
    </script>

    <!--<link rel="stylesheet" href="/assets/css/styles.css">
    <link rel="stylesheet" href="/assets/css/print.css" media="print">

    <meta name="description" content="Page description">
    <meta property="og:title" content="Unique page title - My Site">
    <meta property="og:description" content="Page description">
    <meta property="og:image" content="https://www.mywebsite.com/image.jpg">
    <meta property="og:image:alt" content="Image description">
    <meta property="og:locale" content="en_GB">
    <meta property="og:type" content="website">
    <meta name="twitter:card" content="summary_large_image">
    <meta property="og:url" content="https://www.mywebsite.com/page">
    <link rel="canonical" href="https://www.mywebsite.com/page">

    <link rel="icon" href="/favicon.ico">
    <link rel="icon" href="/favicon.svg" type="image/svg+xml">
    <link rel="apple-touch-icon" href="/apple-touch-icon.png">
    <link rel="manifest" href="/my.webmanifest">
    <meta name="theme-color" content="#FF00FF">-->

    <script src="https://unpkg.com/konva@^2/konva.min.js"></script>
</head>
<body style="margin: 0;">
    <div id="container">

    </div>

    <script>
        // Deterministic random
        function mulberry32(a) {
            //return function() {
            var t = a += 0x6D2B79F5;
            t = Math.imul(t ^ t >>> 15, t | 1);
            t ^= t + Math.imul(t ^ t >>> 7, t | 61);
            return ((t ^ t >>> 14) >>> 0) / 4294967296;
            //}
        }

        // Starting position of the canvas. We set it to some far away place from <0, 0> b/c
        // there's symmetry with the randomness at around the origin point.
        const startingPosition = {
            x: Math.floor( Math.random() * 10000),
            y: Math.floor( Math.random() * 10000),
        }

        // Setup Konva.
        const stage = new Konva.Stage({
            container: 'container',
            width: document.documentElement.clientWidth, //window.innerWidth,
            height: document.documentElement.clientHeight, //window.innerHeight,
            draggable: true
        })
        const layer = new Konva.Layer();
        stage.add(layer);

        //// Define cell width and height.
        const WIDTH = 100;
        const HEIGHT = 100;

        //// Define available color for each cell.
        const items = [
            'red', 'yellow', 'green', 'blue', 'orange', 'gray',
        ]
        
        function _fillLayer() {
            //console.log(`pos=<${stage.x()}, ${stage.y()}>`)

            const startX = Math.floor((-stage.x() - stage.width()) / WIDTH) * WIDTH;
            const endX = Math.floor((-stage.x() + stage.width() * 2) / WIDTH) * WIDTH;
          
            const startY = Math.floor((-stage.y() - stage.height()) / HEIGHT) * HEIGHT;
            const endY = Math.floor((-stage.y() + stage.height() * 2) / HEIGHT) * HEIGHT;
          
            for (var x = startX; x < endX; x += WIDTH) {
                for (var y = startY; y < endY; y += HEIGHT) {
                    let indexX = Math.abs((x + startingPosition.x) / WIDTH);
                    let indexY = Math.abs((y + startingPosition.y) / HEIGHT);

                    // map index |--> element in item, pseudo-random deterministically.
                    let randv = Math.floor( mulberry32(indexX * indexY) * 12345);
                    let color = items[ randv % items.length ];

                    layer.add(new Konva.Rect({
                        x,
                        y,
                        width: WIDTH,
                        height: HEIGHT,
                        fill: color,
                    }))
                }
            }
        }
        // Generates random cells on the canvas and draws the canvas.
        const generate = () => {
            console.log(new Date().toISOString() + ' generate()')
            layer.destroyChildren();
            _fillLayer();
            layer.draw();
        }

        // Drag end event listener.
        stage.on('dragend', () => {
            generate()
        })

        // Wheel event listener.
        let __wheelDebounceTimer = null
        stage.on('wheel', ev => {
            const {
                deltaX,
                deltaY,
                wheelDeltaX,
                wheelDeltaY,
                which,
                x, y
            } = ev.evt || {}

            stage.setX(stage.x() - deltaX)
            stage.setY(stage.y() - deltaY)

            clearTimeout(__wheelDebounceTimer)
            __wheelDebounceTimer = setTimeout(() => {
                generate()
            }, 100)

            layer.draw();
        });

        generate();
    </script>
</body>
</html>